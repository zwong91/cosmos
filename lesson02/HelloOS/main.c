//彭东 @ 2021.01.09
#include "vgastr.h"
//CPU三种工作模式
/*
1. 实模式  单进程 16 位地址空间，分段的内存模型; 对指令不加限制地运行，对内存没有保护隔离作用
寄存器是16 位 2^16，但是地址总线却有 20 根，根据计算 2^20 = 1M， 
段寄存器左移 4 位， 段基地址左移4位，形成20位基地址。然后加上偏移量16位，最终形成20位物理地址……可寻址1MB   CS:IP

2. 保护模式 多进程 寻址 32 位的内存地址空间和处理 32 位的数据  特权级 EIP
3. 长模式(AMD64 模式)  处理 64 位数据和寻址 64 位的内存地址空间的能力  弱化段模式管理，只保留了权限级别, MMU地址检查  RIP
*/

// MMU 内存地址转换， 内存隔离和安全。

// 程序局部性原理: CPU 大多数时间在执行相同的指令或者与此相邻的指令
/*
多核CPU三级缓存和内存交互
Cache一致性协议  M、E、S、I，即修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）

volatile   可见性，有序性  volatile 的内存语义  确保共享变量得到一致和可靠的更新，可以通过锁，也可以通过更轻量的 volatile 关键字，
volatile保证线程间可见性和禁止指令重排序
1. 线程 1 将新值写入缓存后，立刻刷新到内存中。
2. 这个写入内存的操作，使线程 2 的缓存无效。若想读取该共享变量，则需要重新从内存中获取


_> cpu  mesi缓存一致性和总线嗅探机制
1. 立即将该处理器缓存（具体说是缓存行）中的数据刷新到内存。
2. 使得其他处理器缓存（具体说是缓存了该内存地址的缓存行）失效

*/

void main()
{
    printf("Hello OS!");
    return;
}
